## Workflow 4: Using telepresence for automated testing of cloud-native code

Users can utilize the fact that all the endpoints within the K8s cluster are made available to the workstation once telepresence is connected to the K8s cluster. They can create scripts for automation/testing and also use tools like Postman, curl, netcat, nslookup on your workstation to test the microservice and the entire architecture from within the K8s cluster.

Let's consider an example where there are 2 versions of microservices that provide some processed data from their API endpoints which will be further used by the rest of the application workflow and you want to test this microservice live and compare the data returned by both the services. 

To set this up, download the source code as mentioned here and navigate to iatcp-telepresence-maheshp-telepresence-examples-v1/example2/
```
[maheshp@vdi-dd1bgl-022:~/Desktop] ...
$ ls
iatcp-telepresence-maheshp-telepresence-examples-v1/
 
$ cd iatcp-telepresence-maheshp-telepresence-examples-v1/example4/
```
### Steps to create the example4 deployment on K8s cluster
| Id | Steps | Details|
| -- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  | First, we will create the container images.<br><br>Navigate to the example4/example4-image folder.<br><br>Build the docker image of the first microservice and load it to minikube| <pre>#Current directory<br>$ pwd<br>/home/maheshp/Desktop/iatcp-telepresence-maheshp-telepresence-examples-v1/example4<br> <br>#Navigate to example4-image<br>$ cd example4-image/<br> <br># Building the image<br>$ docker build -t example4:v1 . <br> <br>#Load the image to minikube<br>$ minikube image load example4:v1<br></pre>|
| 2  | Now let's create and update the microservice and the docker file to create a new version of the microservice (v2).| |
| 3  | First edit the file  example4/example4-image/main.go with the following changes:-<br>1\. Update the value of age for any user ( this will simulate the deviation in the data served by the new version)<br>2\. Update the API endpoint port.| 1\. ![image1](images/workflow4/image1.png)<br>2. ![image2](images/workflow4/image2.png)|
| 4  | Next, we will update the API endpoint to be exposed in the docker file as well| ![image3](images/workflow4/image3.png)|
| 5  | Now we build and load the image of the updated microservice (v2)| <pre># Building the image<br>$ docker build -t example4:v2 .<br> <br>#Load the image to minikube<br>$ minikube image load example4:v2<br> <br>#Navigate back to application directory<br>$ cd ..<br></pre>|
| 6  | We can now deploy the 2 microservices app1-my-microservice and app2-my-microservice<br>To do this go to Telepresence-examples-main/example4/helm/ and run the mentioned commands| <pre>#Navigate to helm directory<br>$ cd helm/<br> <br>$ pwd<br>/home/maheshp/Desktop/iatcp-telepresence-maheshp-telepresence-examples-v1/example4/helm<br> <br>#Installing first microservice<br>$ helm install app1 my-microservice<br> <br>#Installing second microservice<br>$ helm install app2 my-microservice -f values2.yaml<br> <br>#Naviagate back to the application folder<br>$ cd ..<br></pre> |
| 7  | Since the services of the deployments in the K8s cluster is of type ClusterIP, the endpoints are only exposed to the internal network of the K8s cluster, and hence<br>the user cannot interact with the API endpoints or microservices from his workstation | |

###  Steps to create a script to test the K8s workloads with telepresence
| Id | Steps| Details |
| -- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1  | Once the microservices are deployed to the K8s cluster the resources and endpoints of the microservice are isolated to the K8s network and are not accessible directly.<br><br>We can see that when we try to curl or perform nslookup the internal service urls | <pre>#These are the k8 services of the miroservices app1 and app2<br>$ kubectl get svc<br> NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   <br>app1-my-mircoservice   ClusterIP   10.107.194.180   <none>        5000/TCP  <br>app2-my-mircoservice   ClusterIP   10.100.187.151   <none>        5001/TCP  <br> <br> <br> <br> <br>$ nc -zv  app1-my-microservice.default 8080<br>nc: getaddrinfo for host "app1-my-microservice.default" port 8080: Name or service not known  <br> <br> <br>$ curl http://app1-my-microservice.default:8080/users<br>curl: (6) Could not resolve host: app1-my-microservice.default  <br> <br> <br>$ nslookup app1-my-microservice.default<br>Server:         172.18.74.9<br>Address:        172.18.74.9#53<br> <br>\*\* server can't find app1-my-microservice.default: NXDOMAIN<br></pre> |
| 2  | Connect telepresence to your K8s cluster | <pre>$ telepresence connect<br>Connected to context minikube (https://192.168.49.2:8443)<br></pre>  |
| 3  | Once telepresence is connected to your K8s cluster your workstation behaves as part of the K8s internal network and hence all the resources are now accessible.<br><br>we can see that all the commands that previously failed now succeed                       | <pre>$ nslookup app1-my-microservice.default<br>Server:         172.18.74.9<br>Address:        172.18.74.9#53<br> <br>Name:   app1-my-microservice.default<br>Address: 10.104.129.106  <br> <br>$ curl http://app1-my-microservice.default:8080/users<br>[{"name":"Alice","age":23},{"name":"Bob","age":30},{"name":"Charlie","age":35}]  <br> <br>$ nc -zv  app1-my-microservice.default 8080<br>Connection to app1-my-microservice.default (10.104.129.106) 8080 port [tcp/http-alt] succeeded!<br></pre> |
| 4  | We can hit the service URLs directly to on the workstation browser as well  | ![image4](images/workflow4/image4.png)  |
| 5  | We can run scripts (example4/main.go )from our workstation which refer to these internal endpoints directly | <pre>#Current directory<br>$ pwd<br>/home/maheshp/Desktop/iatcp-telepresence-maheshp-telepresence-examples-v1/example4<br> <br>$ ls<br>example4-image/  helm/  main.go  readme-example4<br> <br> <br># Run the golang http server<br>  go run main.go<br></pre>  |
| 6  | Here we can see that the script creates GET requests to each microservice and then compares the responses and prints a relevant message if there is a deviation in the response| <pre>#Below code snippet is from the main.go script in the previous step.<br>#We can see that the code executes a get request to the API endpoint which is only accesible from within the K8s cluster<br> <br> <br> <br>resp, err := http.Get("http://app1-my-microservice.default:8080/users")<br>    if err != nil {<br>        fmt.Println("Error: ", err)<br>        return<br>    }<br>    defer resp.Body.Close()<br> <br>resp1, err := http.Get("http://app2-my-microservice.default:8081/users")<br>    if err != nil {<br>        fmt.Println("Error: ", err)<br>        return<br>    }<br>    defer resp1.Body.Close()<br></pre>  |
| 7  | Similarly, developers can use any tool or language they prefer to interact with the microservices  and automate tests inside the K8s cluster| |
| 8  | Once you are done working, you can terminate the telepresence connection to the K8s cluster | <pre>#Run the below command to disconnect  telepresence<br>$ telepresence quit<br>Telepresence Daemons disconnecting...done<br></pre>|
| 9  | To clean up the K8s cluster we can use Helm to uninstall the deployment| <pre>$ helm uninstall app1<br>release "app1" uninstalled<br> <br>$ helm uninstall app2<br>release "app2" uninstalled<br></pre>|
